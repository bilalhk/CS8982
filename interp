#lang eopl

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Lexer and parser specification.

(define scanner-spec-3-1
  '((white-sp
     (whitespace) skip)
    (comment
     ("%" (arbno (not #\newline))) skip)
    (identifier
     (letter (arbno (or letter digit "?"))) symbol)
    (number
     (digit (arbno digit)) number)))

(define grammar-3-1
  '((program ((arbno class-decl) expression) a-program)
    (class-decl
     ("class" identifier "extends" identifier (arbno "field" identifier) (arbno method-decl))
     a-class-decl)
    (method-decl
     ("method" identifier "(" (separated-list identifier ",") ")" expression)
     a-method-decl)
    (expression
     ("new" identifier "(" (separated-list expression ",") ")")
     new-object-exp)
    (expression
     ("send" expression identifier "(" (separated-list expression ",") ")")
     method-app-exp)
    (expression
     ("super" identifier "(" (separated-list expression ",") ")")
     super-call-exp)
    (expression (number) lit-exp)
    (expression (identifier) var-exp)
    (expression
     (primitive "(" (separated-list expression ",") ")")
     primapp-exp)
    (expression ("array" "(" expression ")") arrayapp-exp)
    (expression ("arrayref" "(" expression "," expression ")") arrayref-exp)
    (expression ("arrayset" "(" expression "," expression "," expression ")") arrayset-exp)
    (expression
     ("if" expression "then" expression "else" expression)
     if-exp)
    (expression
     ("let" (arbno identifier "=" expression) "in" expression)
     let-exp)
    (expression
     ("letrec" (arbno identifier "(" (separated-list identifier ",") ")" "=" expression) "in" expression)
     letrec-exp)
    (expression
     ("proc" "(" (separated-list identifier ",") ")" expression)
     proc-exp)
    (expression
     ("(" expression (arbno expression) ")")
     app-exp)
    (expression
     ("set" identifier "=" expression)
     varassign-exp)
    (expression
     ("begin" expression (arbno ";" expression) "end")
     begin-exp)
    (expression ("true") true-exp)
    (expression ("false") false-exp)
    (primitive ("+") add-prim)
    (primitive ("-") subtract-prim)
    (primitive ("*") mult-prim)
    (primitive ("add1") incr-prim)
    (primitive ("sub1") decr-prim)
    (primitive ("equal?") equal-prim)
    (primitive ("zero?") zero-prim)
    (primitive ("greater?") greater-prim)
    (primitive ("less?") less-prim)))

(define scan&parse (sllgen:make-string-parser scanner-spec-3-1 grammar-3-1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Data Representations and interfaces.

(define-datatype program program?
  (a-program (class-decls (list-of class-decl?)) (expression expression?)))

(define-datatype class-decl class-decl?
  (a-class-decl (class-name symbol?)
                (super-name symbol?)
                (field-ids (list-of symbol?))
                (method-decls (list-of method-decl?))))

(define-datatype method-decl method-decl?
  (a-method-decl (method-name symbol?)
                 (ids (list-of symbol?))
                 (body expression?)))

(define-datatype method method?
  (a-method (method-decl method-decl?)
            (super-name symbol?)
            (field-ids (list-of symbol?))))

(define-datatype expression expression?
  (lit-exp (datum number?))
  (var-exp (id symbol?))
  (primapp-exp (prim primitive?) (rands (list-of expression?)))
  (arrayapp-exp (texp type-exp?) (size expression?))
  (arrayref-exp (array-exp expression?) (index-exp expression?))
  (arrayset-exp (array-exp expression?) (index-exp expression?) (val-exp expression?))
  (if-exp (test-exp expression?) (then-exp expression?) (else-exp expression?))
  (let-exp (ids (list-of symbol?)) (rands (list-of expression?)) (body expression?))
  (letrec-exp (proc-names (list-of symbol?))          
              (idss (list-of (list-of symbol?)))
              (bodies (list-of expression?))
              (letrec-body expression?))
  (proc-exp (ids (list-of symbol?)) (body expression?))
  (app-exp (rator expression?) (rands (list-of expression?)))
  (varassign-exp (id symbol?) (rhs-expression expression?))
  (begin-exp (exp expression?) (exps (list-of expression?)))
  (new-object-exp (class-name symbol?) (rands (list-of expression?)))
  (method-app-exp (obj-exp expression?) (method-name symbol?) (rands (list-of expression?)))
  (super-call-exp (method-name symbol?) (rands (list-of expression?)))
  (true-exp)
  (false-exp)
  (lexvar-exp (depth number?) (position number?))
  (lexlet-exp (rands (list-of expression?)) (body expression?))
  (lexproc-exp (body expression?))
  (lexletrec-exp (bodies (list-of expression?)) (letrec-body expression?))
  (lexvarassign-exp (lexvar expression?) (rhs-expression expression?)))

(define-datatype type-exp type-exp?
  (int-type-exp)
  (bool-type-exp)
  (proc-type-exp (arg-texps (list-of type-exp?)) (result-texps type-exp?))
  (array-type-exp (texp type-exp?)))

(define-datatype optional-type-exp optional-type-exp?
  (a-type-exp (texp type-exp?))
  (no-type-exp))

(define-datatype primitive primitive?
  (add-prim)
  (subtract-prim)
  (mult-prim)
  (incr-prim)
  (decr-prim)
  (equal-prim)
  (zero-prim)
  (greater-prim)
  (less-prim))

(define-datatype procval procval?
  (closure (ids (list-of symbol?)) (body expression?) (env environment?)))

(define-datatype object object?
  (an-object (class-name symbol?) (fields vector?)))

(define-datatype class class?
  (a-class (class-name symbol?)
           (super-name symbol?)
           (field-length integer?)
           (field-ids (list-of symbol?))
           (methods (list-of method?))))

(define-datatype environment environment?
  (empty-env-record)
  (extended-env-record (ids (list-of symbol?)) (vals vector?) (env environment?))
  (recursively-extended-env-record (proc-names (list-of symbol?))
                                   (idss (list-of (list-of symbol?)))
                                   (bodies (list-of expression?))
                                   (env environment?)))

(define (recursively-extend-env proc-names idss bodies old-env)
  (recursively-extended-env-record proc-names idss bodies old-env))

(define (extend-env ids vals old-env)
  (extended-env-record ids vals old-env))

(define (empty-env)
  (empty-env-record))

(define (apply-env-ref env sym)
  (cases environment env
    (empty-env-record () (eopl:error 'empty-env "No binding for ~s" sym))
    (extended-env-record (syms vals old-env)
                         (let ((pos (list-find-position sym syms)))
                           (if (number? pos)
                               (a-ref pos vals)
                               (apply-env old-env sym))))
    (recursively-extended-env-record (proc-names idss bodies old-env)
                                     (let ((pos (list-find-position sym proc-names)))
                                       (if (number? pos)
                                           (closure (list-ref idss pos) (list-ref bodies pos) env)
                                           (apply-env old-env sym))))))

(define (apply-env env sym)
  (deref (apply-env-ref env sym)))

(define-datatype nameless-environment nameless-environment?
  (empty-nameless-env-record)
  (nameless-extended-env-record
   (vals vector?)
   (env nameless-environment?))
  (nameless-recursively-extended-env-record (bodies (list-of expression?)) (env nameless-environment?)))

(define (empty-nameless-env)
  (empty-nameless-env-record))

(define (extend-nameless-env vals env)
  (nameless-extended-env-record vals env))

(define (recursively-extend-nameless-env bodies old-env)
  (nameless-recursively-extended-env-record bodies old-env))

(define (apply-nameless-env env depth pos)
  (deref (apply-nameless-env-ref env depth pos)))

(define (apply-nameless-env-ref env depth pos)
  (if (= depth 0)
      (cases nameless-environment env
        (nameless-extended-env-record (vals env) (a-ref pos vals))
        (nameless-recursively-extended-env-record (bodies old-env) (closure (list-ref bodies pos) env))
        (else (eopl:error 'apply-nameless-env-ref "No binding found for variable with lexical address ~d ~p" depth pos)))
      (cases nameless-environment env
        (nameless-extended-env-record (vals old-env) (apply-nameless-env-ref old-env (- depth 1) pos))
        (nameless-recursively-extended-env-record (bodies old-env) (apply-nameless-env-ref old-env (- depth 1) pos))
        (else (eopl:error 'apply-nameless-env-ref "No binding found for variable with lexical address ~d ~p" depth pos)))))

(define-datatype reference reference?
  (a-ref (position integer?) (vec vector?)))

(define (primitive-deref ref)
  (cases reference ref
    (a-ref (pos vec) (vector-ref vec pos))))

(define (primitive-setref! ref val)
  (cases reference ref
    (a-ref (pos vec) (vector-set! vec pos val))))

(define (deref ref)
  (primitive-deref ref))

(define (setref! ref val)
  (primitive-setref! ref val))

;; Environment for storing declarations. Used for calculating lexical addresses.
(define-datatype declarations declarations?
  (empty-declarations)
  (extended-declarations (current-scope (list-of symbol?)) (higher-scopes declarations?)))

(define (create-lexvar-exp id decs)
  (define (calc-address-with-depth id decs depth)
    (cases declarations decs
      (empty-declarations () (eopl:error 'calc-address "No declaration found for ~s" id))
      (extended-declarations (current-scope higher-scopes)
                             (let ((pos (list-find-position id current-scope)))
                               (if (number? pos)
                                   (lexvar-exp depth pos)
                                   (calc-address-with-depth id higher-scopes (+ depth 1)))))))
  
  (calc-address-with-depth id decs 0))

(define-datatype type type?
  (atomic-type (name symbol?))
  (proc-type (arg-types (list-of type?)) (result-type type?))
  (array-type (type type?))
  (type-var (serial-number integer?) (container vector?))) 

(define int-type (atomic-type 'int))
(define bool-type (atomic-type 'bool))

;; Environment for storing types. Used for checking the type of an expression.
(define-datatype type-environment type-environment?
  (empty-type-environment)
  (extended-type-environment (ids (list-of symbol?)) (types (list-of type?)) (old-tenv type-environment?)))

;; ListOf(Symbol) * ListOf(Type) * Type-environment -> Type-environment
(define (extend-tenv ids types old-tenv)
  (extended-type-environment ids types old-tenv))

;; Symbol * Type-environment -> Type
(define (apply-tenv id tenv)
  (cases type-environment tenv
    (empty-type-environment () (eopl:error 'apply-tenv "Variable with id ~s not found in type-environment ~s" id tenv))
    (extended-type-environment (ids types old-tenv)
                               (let ((pos (list-find-position id ids)))
                                 (if (number? pos)
                                     (list-ref types pos)
                                     (apply-tenv id old-tenv))))))

(define true-value?
  (lambda (value)
    (not (zero? value))))

(define scheme-value? (lambda (v) #t))

(define the-class-env '())

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utility functions.

(define (init-nameless-env)
  (extend-nameless-env (list->vector '(1 5 10)) (empty-nameless-env)))

(define (init-env)
  (empty-env))

(define (list-of pred)
  (lambda (val)
    (or (null? val)
        (and (pair? val)
             (pred (car val))
             ((list-of pred) (cdr val))))))

;; Symbol * ListOfSymbol -> Number/Boolean
;; Returns position of Symbol in ListOfSymbol if Symbol is found. If not found, returns false.
(define (list-find-position sym los)
  (define (find-pos sym los)
    (cond
      ((eq? sym (car los)) 0)
      (else (+ 1 (find-pos sym (cdr los))))))
  (define (member? sym los)
    (cond
      ((null? los) #f)
      (else (or (eq? sym (car los))
                (member? sym (cdr los))))))
  
  (cond
    ((not (member? sym los)) #f)
    (else (find-pos sym los))))

(define (iota upper-limit)
  (define (generate-list n)
    (if (>= n upper-limit)
        '()
        (cons n (generate-list (+ n 1)))))
  
  (generate-list 0))

(define (run string)
  (eval-program (scan&parse string)))

(define (eval-program pgm)
  (cases program pgm
    (a-program (c-decls exp)
               (begin (elaborate-class-decls! c-decls)
                      (eval-expression exp (init-env))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Evaluator

(define (eval-expression exp env)
  (cases expression exp
    (lit-exp (datum) datum)
    (var-exp (id) (apply-env env id))
    (primapp-exp (prim rands) (apply-primitive prim (eval-rands rands env)))
    (arrayapp-exp (type-exp size-exp) (apply-arrayapp-exp size-exp env))
    (arrayref-exp (array-exp index-exp) (apply-arrayref-exp array-exp index-exp env))
    (arrayset-exp (array-exp index-exp val-exp) (apply-arrayset-exp array-exp index-exp val-exp env))
    (if-exp (test-exp true-exp false-exp) (eval-if-exp test-exp true-exp false-exp env))
    (let-exp (ids rands body) (eval-let-exp ids rands body env))
    (proc-exp (ids body) (closure ids body env))
    (app-exp (rator rands) (eval-app-exp rator rands env))
    (letrec-exp (proc-names idss bodies letrec-body) (eval-expression letrec-body (recursively-extend-env proc-names idss bodies env)))
    (varassign-exp (id rhs-expression) (eval-varassign-exp id rhs-expression env))
    (begin-exp (exp exps) (eval-begin-exp exp exps env))
    (new-object-exp (class-name rands) (eval-new-object-exp class-name rands env))
    (else (eopl:error 'eval-expression "Interpreter does not understand expression ~e" exp))))

(define (eval-new-object-exp class-name rands env)
  (let ((args (eval-rands rands env))
        (obj (new-object class-name)))
    (begin (find-method-and-apply 'initialize class-name obj args)
           obj)))

(define (apply-arrayapp-exp size-exp env)
  (let ((size (eval-expression size-exp env)))
    (make-vector size)))

(define (apply-arrayref-exp array-exp index-exp env)
  (let ((array (eval-expression array-exp env))
        (index (eval-expression index-exp env)))
    (vector-ref array index)))

(define (apply-arrayset-exp array-exp index-exp val-exp env)
  (let ((array (eval-expression array-exp env))
        (index (eval-expression index-exp env))
        (val (eval-expression val-exp env)))
    (begin (vector-set! array index val)
           1)))

(define (eval-if-exp test-exp true-exp false-exp env)
  (if (true-value? (eval-expression test-exp env))
      (eval-expression true-exp env)
      (eval-expression false-exp env)))

(define (eval-let-exp ids rands body env)
  (let* ((args (eval-rands rands env))
         (extended-env (extend-env ids (list->vector args) env)))
    (eval-expression body extended-env)))

(define (eval-app-exp rator rands env)
  (let ((proc (eval-expression rator env))
        (args (eval-rands rands env)))
    (if (procval? proc)
        (apply-procval proc args)
        (eopl:error 'app-exp-eval-expression "Attempt to apply non-procedure ~s" proc))))

(define (eval-varassign-exp id rhs-expression env)
  (let ((new-val (eval-expression rhs-expression env))
        (var-ref (apply-env-ref env id)))
    (begin (setref! var-ref new-val)
           1)))

(define (eval-begin-exp exp exps env)
  (if (null? exps)
      (eval-expression exp env)
      (begin (eval-expression exp env)
             (eval-expression (begin-exp (car exps) (cdr exps)) env))))

(define (eval-rands rands env)
  (map (lambda (x) (eval-rand x env)) rands))

(define (eval-rand rand env)
  (eval-expression rand env))

(define (apply-procval proc args)
  (cases procval proc
    (closure (ids body env)
             (let ((extended-env (extend-env ids (list->vector args) env)))
               (eval-expression body extended-env)))))

(define (apply-primitive prim args)
  (cases primitive prim
    (add-prim () (+ (car args) (cadr args)))
    (subtract-prim () (- (car args) (cadr args)))
    (mult-prim () (* (car args) (cadr args)))
    (incr-prim () (+ (car args) 1))
    (decr-prim () (- (car args) 1))
    (equal-prim () (if (= (car args) (cadr args))
                       1
                       0))
    (zero-prim () (if (zero? (car args))
                      1
                      0))
    (greater-prim () (if (> (car args) (cadr args))
                         1
                         0))
    (less-prim () (if (< (car args) (cadr args))
                      1
                      0))))

;; Symbol -> Object
(define (new-object class-name)
  (an-object class-name
             (make-vector (class-name->field-length class-name))))

;; Lof(Class-decl) -> none
(define (elaborate-class-decls! c-decls)
  (begin (set! the-class-env '())
         (for-each elaborate-class-decl! c-decls)))

;; Class-decl -> none
(define (elaborate-class-decl! c-decl)
  (let* ((super-name (class-decl->super-name c-decl))
         (field-ids (append (class-name->field-ids super-name)
                            (class-decl->field-ids c-decl))))
    (add-to-class-env! (a-class (class-decl->class-name c-decl)
                                super-name
                                (length field-ids)
                                field-ids
                                (roll-up-method-decls c-decl super-name field-ids)))))

;; Class-decl * Symbol * Lof(Symbol) -> Lof(Method)
(define (roll-up-method-decls c-decl super-name field-ids)
  (map (lambda (method-decl)
         (a-method method-decl super-name field-ids))
       (class-decl->method-decls c-decl)))

;; Class-decl -> Symbol
(define (class-decl->super-name c-decl)
  (cases class-decl c-decl
    (a-class-decl (class-name super-name field-ids method-decls) super-name)
    (else (eopl:error 'class-decl->super-name "Interpreter does not understand class-declaration ~s" c-decl))))

;; Symbol -> Lof(Symbol)
(define (class-name->field-ids super-name)
  (define (class-env->field-ids class-env)
    (if (null? class-env)
        '()
        (let ((curr-class (car class-env)))
          (cases class curr-class
            (a-class (class-name super-name field-length field-ids methods)
                     (if (eq? super-name class-name)
                         field-ids
                         (class-env->field-ids (cdr class-env))))))))
  
  (class-env->field-ids the-class-env))

;; Symbol -> Number
(define (class-name->field-length name)
  (define (class-env->field-length class-env)
    (if (null? class-env)
        (eopl:error 'class-name->field-length "Class ~s not found in class-declarations" name) 
        (let ((curr-class (car class-env)))
          (cases class curr-class
            (a-class (class-name super-name field-length field-ids methods)
                     (if (eq? name class-name)
                         field-length
                         (class-env->field-length (cdr class-env))))))))
  
  (class-env->field-length the-class-env))


;; Class-decl -> Lof(Symbol)
(define (class-decl->field-ids c-decl)
  (cases class-decl c-decl
    (a-class-decl (class-name super-name field-ids method-decls) field-ids)))

;; Class -> none
(define (add-to-class-env! class)
  (set! the-class-env (cons class the-class-env)))

;; Class-decl -> Symbol
(define (class-decl->class-name c-decl)
  (cases class-decl c-decl
    (a-class-decl (class-name super-name field-ids method-decls) class-name)))

;; Class-decl -> Method-decl
(define (class-decl->method-decls c-decl)
  (cases class-decl c-decl
    (a-class-decl (class-name super-name field-ids method-decls) method-decls)))

;; Symbol * Symbol -> Method/Boolean
(define (lookup-method method-name class-name)
  (let ((methods (class-name->methods class-name)))
    (list-find-method method-name methods)))

;; Symbol * Lof(Method) -> Method/Boolean
(define (list-find-method method-name methods)
  (if (null? methods)
      #f
      (let* ((curr-method (car methods))
             (curr-method-name (method->method-name curr-method)))
        (if (eq? method-name curr-method-name)
            curr-method
            (list-find-method method-name (cdr methods))))))

;; Method -> Symbol
(define (method->method-name meth)
  (cases method meth
    (a-method (meth-decl super-name field-ids)
              (cases method-decl meth-decl
                (a-method-decl (method-name ids body) method-name)))))

;; Method -> Lof(Symbol)
(define (method->ids meth)
  (cases method meth
    (a-method (meth-decl super-name field-ids)
              (cases method-decl meth-decl
                (a-method-decl (method-name ids body) ids)))))

;; Method -> Expression
(define (method->body meth)
  (cases method meth
    (a-method (meth-decl super-name field-ids)
              (cases method-decl meth-decl
                (a-method-decl (method-name ids body) body)))))


;; Symbol -> Lof(Method)
(define (class-name->methods name)
  (define (class-env->methods class-env)
    (if (null? class-env)
        (eopl:error 'class-name->methods "Class ~s not found in class-declarations" name) 
        (let ((curr-class (car class-env)))
          (cases class curr-class
            (a-class (class-name super-name field-length field-ids methods)
                     (if (eq? name class-name)
                         methods
                         (class-env->methods (cdr class-env))))))))
  
  (class-env->methods the-class-env))

;; Symbol -> Symbol
(define (class-name->super-name name)
  (define (class-env->super-name class-env)
    (if (null? class-env)
        (eopl:error 'class-name->super-name "Class ~s not found in class-declarations" name) 
        (let ((curr-class (car class-env)))
          (cases class curr-class
            (a-class (class-name super-name field-length field-ids methods)
                     (if (eq? name class-name)
                         super-name
                         (class-env->super-name (cdr class-env))))))))
  
  (class-env->super-name the-class-env))

;; Symbol * Symbol * Object * Lof(Expression) -> Expression/none
(define (find-method-and-apply method-name class-name self args)
  (if (eq? class-name 'object)
      (eopl:error 'find-method-and-apply "No method for name ~s" method-name)
      (let ((method (lookup-method method-name class-name)))
        (if (method? method)
            (apply-method method self args)
            (find-method-and-apply method-name (class-name->super-name class-name) self args)))))

;; Method * Object * Lof(Expression) -> Expression/none
(define (apply-method method self args)
  (let ((ids (method->ids method))
        (body (method->body method))
        (super-name (method->super-name method))
        (field-ids (method->field-ids method))
        (fields (object->fields self)))
    (eval body
          (extend-env (list '%super 'self 'ids)
                      (list super-name self args)
                      (extend-env (list field-ids fields (empty-env)))))))